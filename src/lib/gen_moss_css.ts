import type {Gen} from '@ryanatkn/gro/gen.js';
import type {File_Filter} from '@ryanatkn/gro/path.js';

import type {
	Css_Class_Declaration,
	Css_Class_Declaration_Interpreter,
} from '$lib/css_class_helpers.js';
import {collect_css_classes, Css_Classes, generate_classes_css} from '$lib/css_class_helpers.js';
import {css_classes_by_name} from '$lib/css_classes.js';
import {css_class_interpreters} from '$lib/css_class_interpreters.js';

export interface Gen_Moss_Css_Options {
	filter_file?: File_Filter | null;
	include_stats?: boolean;
	classes_by_name?: Record<string, Css_Class_Declaration | undefined>;
	class_interpreters?: Array<Css_Class_Declaration_Interpreter>;
}

const filter_file_default: File_Filter = (path) => {
	if (path.includes('.test.') || path.includes('/test/') || path.includes('.gen.')) {
		return false;
	}
	const ext = path.slice(path.lastIndexOf('.'));
	return ext === '.svelte' || ext === '.ts' || ext === '.js';
};

export const gen_moss_css = (options: Gen_Moss_Css_Options = {}): Gen => {
	const {
		filter_file = filter_file_default,
		include_stats = false,
		classes_by_name = css_classes_by_name,
		class_interpreters = css_class_interpreters,
	} = options;

	return {
		dependencies: 'all',
		// TODO optimize, do we need to handle deleted files or removed classes though?
		// This isn't as much a problem in watch mode but isn't clean.
		// dependencies: ({changed_file_id, filer}) => {
		// 	if (!changed_file_id) return 'all';
		// 	const disknode = filer.get_by_id(changed_file_id);
		// 	if (disknode?.contents && collect_css_classes(disknode.contents).size) {
		// 		return 'all';
		// 	}
		// 	return null;
		// },
		generate: async ({filer, log, origin_path}) => {
			log.info('generating Moss CSS classes...');

			await filer.init();

			const css_classes = new Css_Classes();

			const stats = {
				total_files: filer.files.size,
				external_files: 0,
				internal_files: 0,
				processed_files: 0,
				files_with_content: 0,
				files_with_classes: 0,
			};

			for (const disknode of filer.files.values()) {
				if (disknode.external) {
					stats.external_files++;
				} else {
					stats.internal_files++;
				}

				if (filter_file && !filter_file(disknode.id)) {
					continue;
				}

				stats.processed_files++;

				if (disknode.contents !== null) {
					stats.files_with_content++;
					const classes = collect_css_classes(disknode.contents);
					if (classes.size > 0) {
						css_classes.add(disknode.id, classes);
						stats.files_with_classes++;
					}
				}
			}

			const unique_classes = new Set();
			for (const file_classes of css_classes.get().values()) {
				for (const class_name of file_classes) {
					unique_classes.add(class_name);
				}
			}

			if (include_stats) {
				log.info('File statistics:');
				log.info(`  Total files in filer: ${stats.total_files}`);
				log.info(`    External: ${stats.external_files}`);
				log.info(`    Internal: ${stats.internal_files}`);
				log.info(`  Files processed (passed filter): ${stats.processed_files}`);
				log.info(`    With content: ${stats.files_with_content}`);
				log.info(`    With CSS classes: ${stats.files_with_classes}`);
				log.info(`  Unique CSS classes found: ${unique_classes.size}`);
			}

			const css = generate_classes_css(css_classes.get(), classes_by_name, class_interpreters);

			const banner = `generated by ${origin_path}`;

			const content_parts = [`/* ${banner} */`];

			if (include_stats) {
				const performance_note = `/* * 
 * File statistics:
 * - Total files in filer: ${stats.total_files}
 * - External dependencies: ${stats.external_files}
 * - Internal project files: ${stats.internal_files}
 * - Files processed (passed filter): ${stats.processed_files}
 * - Files with CSS classes: ${stats.files_with_classes}
 * - Unique classes found: ${unique_classes.size}
 */`;
				content_parts.push(performance_note);
			}

			content_parts.push(css);
			content_parts.push(`/* ${banner} */`);

			return content_parts.join('\n\n');
		},
	};
};
