import {EMPTY_OBJECT} from '@ryanatkn/belt/object.js';
import {throttle} from '@ryanatkn/belt/throttle.js';
import {writeFileSync} from 'node:fs';
import type {Plugin} from '@ryanatkn/gro/plugin.js';
import type {Args} from '@ryanatkn/gro/args.js';
import type {Filer_Observer} from '@ryanatkn/gro/filer.js';
import type {Path_Id} from '@ryanatkn/gro/path.js';
import {format_file} from '@ryanatkn/gro/format_file.js';

import {collect_css_classes, Css_Classes, generate_classes_css} from './css_class_helpers.js';
import {css_classes_by_name} from './css_classes.js';

const FLUSH_DEBOUNCE_DELAY = 500;

export interface Task_Args extends Args {
	watch?: boolean;
}

export interface Gro_Plugin_Moss_Options {
	/**
	 * CSS classes to always include regardless of usage.
	 */
	include_classes?: Array<string> | Set<string> | null;
	/**
	 * Output file path for generated CSS.
	 * @default 'src/routes/moss.css'
	 */
	outfile?: string;
	/**
	 * Filter function to include/exclude files from CSS class extraction.
	 * @default Excludes test files
	 */
	filter_file?: ((path: Path_Id) => boolean) | null;
	/**
	 * Milliseconds to throttle CSS regeneration.
	 * @default 500
	 */
	flush_debounce_delay?: number;
	/**
	 * Banner comment for generated file.
	 * @default 'generated by gro_plugin_moss'
	 */
	banner?: string;
}

export const gro_plugin_moss = ({
	include_classes = null,
	outfile = 'src/routes/moss.css', // TODO maybe support multiple files using file filters to check where to collect them?
	filter_file = (p) => !p.includes('.test.') && !p.includes('/test/'), // TODO hacky, centralize this and maybe exclude other things like `.gen.` files
	flush_debounce_delay = FLUSH_DEBOUNCE_DELAY,
	banner = 'generated by gro_plugin_moss',
}: Gro_Plugin_Moss_Options = EMPTY_OBJECT): Plugin => {
	const css_classes = new Css_Classes(
		Array.isArray(include_classes) ? new Set(include_classes) : include_classes,
	);

	let previous_output: string | undefined;
	let unsubscribe: (() => void) | undefined;

	// Throttled CSS generation to batch multiple changes
	const flush_gen_queue = throttle(
		async () => {
			const css = generate_classes_css(css_classes.get(), css_classes_by_name);
			const contents = `/* ${banner} */\n\n${css}\n\n/* ${banner} */`;
			const output = await format_file(contents, {filepath: outfile});

			// Skip write if output hasn't changed
			if (output === previous_output) return;
			previous_output = output;
			writeFileSync(outfile, output);
		},
		{delay: flush_debounce_delay, when: 'trailing'},
	);

	return {
		name: 'gro_plugin_moss',
		setup: async ({watch, log, filer}) => {
			// For non-watch mode, generate once and exit
			if (!watch) {
				// Scan all existing files to collect classes
				for (const node of filer.nodes.values()) {
					if (node.is_external || node.kind === 'directory') continue;
					if (filter_file && !filter_file(node.id)) continue;

					const contents = node.contents;
					if (contents !== null) {
						const classes = collect_css_classes(contents);
						css_classes.add(node.id, classes);
					}
					await flush_gen_queue(); // TODO BLOCK idk about this design
				}
				return;
			}

			// Create observer for Moss CSS class extraction
			const moss_observer: Filer_Observer = {
				id: 'gro_plugin_moss',

				// Match files we want to extract CSS classes from
				match: (node) => {
					// Skip external files and directories
					if (node.is_external || node.kind === 'directory') return false;

					// Apply user filter
					if (filter_file && !filter_file(node.id)) return false;

					// Check for Svelte, TypeScript, and JavaScript files
					return node.is_svelte || node.is_typescript || node.is_js;
				},

				// No special invalidation needed
				invalidate: 'self',

				// We need file contents to extract CSS classes
				needs_contents: true,
				needs_stats: false,

				// Run in main phase
				phase: 'main',
				priority: 10,

				// Don't track external files or directories
				track_external: false,
				track_directories: false,

				// Handle errors gracefully
				on_error: (error, batch) => {
					log.error('[gro_plugin_moss] Observer error:', error, batch);
					return 'continue';
				},

				// Process file changes
				on_change: (batch) => {
					let changed = false;

					// Process added/updated files
					for (const node of batch.all_nodes) {
						const contents = node.contents;
						if (contents !== null) {
							const classes = collect_css_classes(contents);
							const had_classes = css_classes.has(node.id);
							css_classes.add(node.id, classes);

							// Only mark as changed if this file wasn't already tracked
							// or if its classes actually changed
							if (!had_classes || classes.size > 0) {
								changed = true;
							}
						}
					}

					// Process deleted files
					for (const deleted_id of batch.deleted) {
						if (css_classes.delete(deleted_id)) {
							changed = true;
						}
					}

					// Queue regeneration if anything changed
					if (changed) {
						void flush_gen_queue();
					}
				},
			};

			// Initial scan to collect all existing classes
			for (const node of filer.nodes.values()) {
				if (moss_observer.match!(node)) {
					const contents = node.contents;
					if (contents !== null) {
						const classes = collect_css_classes(contents);
						css_classes.add(node.id, classes);
					}
				}
			}

			// Generate initial CSS
			await flush_gen_queue();

			// Register the observer
			unsubscribe = filer.observe(moss_observer);
		},

		teardown: () => {
			if (unsubscribe) {
				unsubscribe();
				unsubscribe = undefined;
			}
		},
	};
};
